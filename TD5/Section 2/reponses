Question 4 Expliciter et expliquer les deux algorithmes, le naïf et celui qui est optimisé (en nombre de comparaisons).

Algorithme naf : on a deux variables qui traquent l'élément le plus petit et l'élément le plus grand du tableau, puis on itére sur le tableau en comparant chaque élément du tableau avec ces 2 variables.
Les variables sont mises à jour suivant si l'élément en question est plus petit ou plus grand que l'élément le plus petit ou le plus grand courant.

Opt:

Initialiser min et max en tant que dernier élément du tableau.
Itérer sur le tableau par paire de deux éléments, et comparer le minimum et maximum de cette paire avec les variables courantes min et max.


Question 5 Prouver la complexité en nombre de comparaisons de chacun des deux algorithmes.

Naif : Time Complexity: O(n) In this method, total number of comparisons is 1 + 2(n-2) in worst case and 1 + n – 2 in best case.

Opt : Time Complexity: O(n)

       If n is odd/even:    3*(n-1)/2

Question 6
Reproduire les expérimentations réalisées par les auteurs de l’article. Analyser les résultats obtenus. On
utilisera le même langage de programmation et les mêmes caractéristiques concernant les tableaux pris en arguments.

Question 7
Décrire l’analyse de complexité, pour le modèle de prédicteur 1-bit, permettant de s’approcher d’un point
de vue théorique des résultats expérimentaux de l’article.

Question 8
Reproduire ces expérimentations dans un autre langage de programmation (éventuellement dans plusieurs
autres langages), mais toujours sur le même type d’arguments.

Question 9
En utilisant la Section 2 (exercice 2) du TD 4, reproduire ces expérimentation dans le langage de votre
choix, mais sur des tableaux (pris en arguments) contenant des arbres unaires-binaires. Afin de comparer les arbres, on
utilisera la question 2.4 de cet exercice.

Question 10
Expliquer la complexité temporelle en pratique des deux algorithmes (le naïf et le plus astucieux).
